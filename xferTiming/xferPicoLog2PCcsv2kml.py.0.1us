#!/usr/bin/env python3

# Transfer  Pico W  2  logfile from  pico to  PC.   Then convert  this
# logfile to kml format for googleEarth and other such systems.

# Firstly:

###############################################################################
# Python command line program to xfer logfiles/files flashed to the
# Pico W to PC.
#
###############################################################################


# This  file sleeps  after  serial object  commands this  consistantly
# makes the script work.  While xfer.ultimateGPStracker.log.Pico2PC.py
# hangs.

# To be able to run this file  you must have sole access to the serial
# port.   Thus you  have to  kill main.py  on the  pico and  make sure
# thonny is  not connected to  the pico  also.  Connect thonny  to the
# python interpreter  to run the  script. Or  kill thonny and  run the
# script on  the command line.   Note the  first line of  this program
# allows you to run the script on the command line.

# NOTE: also  that a print()(just like  a small sleep) or  an explicit
# small sleep like time.sleeo(0.1)(100ms)  seems to be reaquired after
# each method for the serial  object, serialObj handle.  Otherwise the
# program will hang after vaious commands.

import serial
import time
import sys


def busy_wait_us(us):

    # spins/blocks  this thread  from running.  time.sleep() yeilds  the
    # processor, this does not.  It will allow us to determine the exact
    # minimum time  that we  have to wait  for the GPS  via the  UART to
    # return a line via readline() method.
    
    start = time.perf_counter()
    target = us / 1_000_000
    while (time.perf_counter() - start) < target:
        pass


    
serialPort= "/dev/ttyACM0"
baudRate = 115200 # for the pico it dosen't seem you can change this baudRate


# Open serial port connection to the pico.

# If this script doesn't get a response from the pico within 5 seconds
# it times out  and continues with the program,  hence timout=5.  Here
# serialObj  is  the  handle  for  our  serial  port.   For  instance,
# readline() operation  will wait  at most 5  seconds for  data before
# giving up.
try:
    serialObj = serial.Serial(serialPort, baudRate, timeout=5)
    busy_wait_us(0.1)
except serial.SerialException as e:
    sys.exit(f"Error opening port: {e}")
    

# To clear micropython UART buffer before the rest of my python script
# runs.  Otherwise readline()'s were out of sink.

# Fulsh the micropython UART buffer on the Pico W to PC.

# To be able to run this file  you must have sole access to the serial
# port.   Thus you  have to  kill main.py  on the  pico with  the kill
# switch and  make sure thonny is  not connected to the  pico also, or
# mpremote.  Killing main.py with the  kill switch I think still dumps
# corrupted data into the buffers.
serialObj.write(b"print(\"Input Buffer FLUSH\")\r\n")
serialObj.write(b"print(\"Output Buffer FLUSH\")\r\n")
while True:
    flushLine = serialObj.readline().decode("utf-8").strip()
    print("Waiting for ready, flushLine=", flushLine)
    if flushLine == "Output Buffer FLUSH":
        print("Flushed UART,", flushLine)
        break



# The pico is really the system that xfers the data to this python
# script running on the PC.  So we need to send commands to the pico
# as follows.

# An example of opening the pico logfile and reading the echoed
# response:

# Send bytes,  b, to  the pico,  open the  log file  on the  pico with
# handle filePicoHandle.   'with' keyword  handled opening  an closing
# the file  in our last  lession but here  because we are  running two
# machines, the  pico and the PC.   CR and LF are  required instead of
# doing it manually.

# \r\n are  required by  MicoPython REPL  on the  pico. \r  is carrige
# return and  \n is linfeed/newline.   So together \r\n is  a standard
# EOL sequence used in many communication protocols, especially serial
# terminals.

# The MicroPython REPL(mycropython running on the pico essentially) is
# the interactive prompt that lets you talk directly to a board (like
# the Raspberry Pi Pico or ESP32) running MicroPython. >>> is the REPL
# prompt, waiting for your python code.

# REPL stands for Read–Eval–Print Loop:
# Read → It reads what you type in (a Python command).
# Eval → It evaluates (executes) that command on the microcontroller.
# Print → It prints the result back to you.
#Loop → Then it waits for the next command.

# .write()  method expects  raw bytes  to send  over the  serial port.
# Computers  and microcontrollers  communicate  via  bytes not  python
# string objects.
serialObj.write(b"filePicoHandle=open('ultimateGPStracker.log','r')\r\n")
busy_wait_us(0.1)

# After  the pico  recived the  write() command  it returns/echos  the
# command back to the PC, so we can read it in.

#.decode('utf-8') converts the bytes received from serial port into a
# string.  So, Latitude,Longitude becomes "Latitude,Longitude"

# .strip() removes and leading and trailing whitespace charcters from
# the string, including \r\n
picoCmdResultLine = serialObj.readline().decode('utf-8').strip()
#print("Write to open file succeeded echoed line is= ", picoCmdResultLine)
busy_wait_us(0.1)

# Reading from logfile logfile on the pico to logfile on the PC:

# PC  logfile opened  and filePChandle  is the  program handle  to it.
# Opening the file in write mode  creates the PC logfile if it doesn't
# exist.  If it does exist it overwrites the PC logfile.
with open('ultimateGPStracker.log.OnPC.log', 'w') as filePChandle:

    # Read all the lines of the pico logfile till there are no lines.
    # That is EOF is an empty STRING(hence, double quotes).
    while picoCmdResultLine != "''":

        # Write   a  line   to   the  pico   which   echos  the   sent
        # command(readline())to  the  PC  and  actually  executes  the
        # command on the  pico.  The command is to read  the next line
        # in the logfile.
        serialObj.write(b"filePicoHandle.readline()\r\n")
        busy_wait_us(0.1)

        # Read the echo of the readline() command.

        #.decode('utf-8') converts the bytes received from serial port
        # into    a    string.

        # .strip() removes and leading and trailing whitespace charcters from
        # the string, including \r\n

        # .readline() method blocks waiting from data from the pico or
        # untill the timout.
        echoLine = serialObj.readline().decode('utf-8').strip()
        if not echoLine:
            print("No echo recived from pico, timout hit. Breaking...")
            break
        ###print("Echo Line: ", echoLine)
        busy_wait_us(0.1)

        # Read the lines of the pico logfile
        picoCmdResultLine = serialObj.readline().decode('utf-8').strip()
        if not picoCmdResultLine:
            print("No data received from pico, timout hit. Breaking..")
            break
        ###print("Pico File line: ", picoCmdResultLine)
        busy_wait_us(0.1)
        
        # Write what is  in the logfile on the pico into  the logfile on
        # the PC.
        if picoCmdResultLine.startswith("'") and picoCmdResultLine != "''":
            # Write lines starting with ' but not the blank line ''
            
            # The  Pico   sends  lines   as  string   literals,  e.g.,
            # '-33.77654,150.9693\n'.   The  code  removes  the  extra
            # quotes and  newline: [1:-3] → starts  from 2nd character
            # to 3rd-from-last  (removes leading ' and  trailing \n').
            # Writes the  cleaned line  to the PC  log file,  adding a
            # newline for proper formatting.
            #
            # This removes the \, n, ' ie three characters.
            picoCmdResultLine = picoCmdResultLine[1:-3]
            # newline to have each line under the other instead of side by side
            ###print("Pico File line written to PC logfile=", picoCmdResultLine)
            filePChandle.write(picoCmdResultLine + '\n')
            busy_wait_us(0.1)

# Close the log file on the pico
serialObj.write(b"filePicoHandle.close()\r\n")
busy_wait_us(0.1)

# To clear micopython buffer for safety.
serialObj.write(b"print(\"FINISHED\")\r\n")
while True:
    flushLine = serialObj.readline().decode("utf-8").strip()
    print("Waiting for ready, flushLine=", flushLine)
    if flushLine == "FINISHED":
        print("Flushed UART,", flushLine)
        break

# close the serial port connection from the PC to the pico.
serialObj.close()
busy_wait_us(0.1)



###############################################################################
#                     Convert PC cvs logfile to kml format.
###############################################################################

kml_waypoints = ""
kml_waypoints_path = ""
cvs_file = "ultimateGPStracker.log.OnPC.log"

with open(cvs_file, 'r', encoding='utf-8') as filePChandle:
    # for loop automatically stops at EOF.
    #
    # Each time through the loop, line is assigned the next line of text
    # (including its  trailing \n).  When  there are no more  lines, the
    # iterator  raises a  StopIteration signal  internally.  So  the for
    # loop catches that automatically and exits cleanly.
    for line in filePChandle:
        # remove all leading and trailing whitespace(spaces,tabs,and
        # newlines) from the line just read.
        line = line.strip()
        if not line:
            # skip over blank lines
            continue

        # splits the stirng in two parts at the , delimiter
        latitude, longitude = line.split(',')


        # <Point><coordinates>\n{longitude},{latitude}\n</coordinates></Point>\n"
        # Sets up the waypoints.

        #  <altitudeMode>clampToGround</altitudeMode>   is   used   so
        #  elevation is not  taken into account for  the waypoints, as
        #  otherwise  we may  loose display  of some  waypoints.  Your
        #  waypoints may disappear  due to some error  in the elevation
        #  of your waypoints.

        # kml_waypoints_path connects all the waypoints with a red(setup
        # in  header)   line  path.  Note  that   google  earth  expects
        # longitude,latitude<space>.
        
        # f-strings(formatted string  literal) lets you  embed VARIABLES
        # or expressions directly inside a  string, using {} braces.  It
        # automatically converts numbers to strings.  Cleaner than using
        # plus sign to concatinate strings with variables in them.
        
        kml_waypoints += f"<Point><coordinates>\n{longitude},{latitude}\n</coordinates></Point>\n"
        kml_waypoints_path += f"{longitude},{latitude} \n"

        # {kml_waypoints_path} the f  string kml_waypoints_path needs to
        # be put  within braces  as it  is already  within an  f string.
        # Otherwise, literally  kml_waypoints_path as a string  would be
        # printed in the kml_content.

        # Some other notes on f strings:
        # f-strings are evaluated at the time the string is created.
        # Anything inside {} is evaluated as an expression.
        # Anything outside {} is just literal text.

        # if you weren’t using an f-string, you could also do:

        # Pauth essentially did this:
        # kml_path_footer = """
        # <coordinates>
        # """ + kml_waypoints_path + """
        # </coordinates>
        # """

        # But f  strings are cleaner  and more readable,  especially for
        # multi-line text like KML

        #######################################################################
        # SUMMARY f-string:
        #
        # The  curly  braces {}  are  only  needed around  variables  or
        # expressions whose  values you want inserted  into an f-string.
        # Everything  else outside  the braces  is just  plain text.  It
        # looks     after     changing     variables     to     strings.
        # ######################################################################
        
        
# ### Triple quotes  allow you to write multiline  strings, that include
# spaces, indentation and newlines.

# kml  path header  sets  the name  of the  file  name(Path from  Pico).
# Waypoints  style(black  point,   or  palcemark_circle.png).   And  the
# Placemark  line  sytle(red   path).   <MultiGeometry  </MultiGeometry>
# indicate that  multiple points/waypoints on  the path are going  to be
# added to this section.

# NOTE: for a kml  file there is always a pair  to Opening and Closing
# markers.  eg <Placemark> and </Placemark>.

kml_file_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Path from Pico</name>
    <Style id="pointStyle">
      <IconStyle>
        <Icon><href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href></Icon>
        <scale>1.0</scale>
      </IconStyle>
    </Style>
    <Style id="lineStyle">
      <LineStyle><color>ff0000ff</color><width>3</width></LineStyle>
    </Style>
    <Placemark>
      <styleUrl>#pointStyle</styleUrl>
      <MultiGeometry>
      {kml_waypoints}
      </MultiGeometry>
    </Placemark>
    <Placemark>
      <name>Path</name>
      <styleUrl>#lineStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>clampToGround</altitudeMode>
        <coordinates>
        {kml_waypoints_path}
        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>
"""

kml_file = "ultimateGPStracker.log.OnPC.log.kml"

with open(kml_file, 'w', encoding='utf-8') as filePChandle:
    filePChandle.write(kml_file_content)

# again we have a string kml_file inside a string so we need {}
print(f"KML file {kml_file} created successfully.")

# This will still work but is less clean code
#print("KML file " + kml_file + " created successfully.")
